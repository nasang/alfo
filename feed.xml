<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://nasang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://nasang.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-07-22T04:34:05+00:00</updated><id>https://nasang.github.io/feed.xml</id><title type="html">blank</title><entry><title type="html">LeetCode 1509. Minimum Difference Between Largest and Smallest Value in Three Moves</title><link href="https://nasang.github.io/blog/2024/leetcode-1509/" rel="alternate" type="text/html" title="LeetCode 1509. Minimum Difference Between Largest and Smallest Value in Three Moves"/><published>2024-07-03T09:00:00+00:00</published><updated>2024-07-03T09:00:00+00:00</updated><id>https://nasang.github.io/blog/2024/leetcode-1509</id><content type="html" xml:base="https://nasang.github.io/blog/2024/leetcode-1509/"><![CDATA[<h3 id="1509-minimum-difference-between-largest-and-smallest-value-in-three-moves-medium">1509. Minimum Difference Between Largest and Smallest Value in Three Moves <font color="orange">(Medium)</font></h3> <h4 id="intuition">Intuition</h4> <p>Suppose we have <code class="language-plaintext highlighter-rouge">N</code> numbers. If we remove <code class="language-plaintext highlighter-rouge">3</code> of them, we’re left with <code class="language-plaintext highlighter-rouge">X = N - 3</code> numbers. We can sort the array and then check the distance between the smallest and largest numbers within each window of <code class="language-plaintext highlighter-rouge">X</code> numbers. The smallest of these distances is our answer.</p> <h4 id="initial-solution">Initial Solution</h4> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Time: O(NlogN)
# Space: O(1)
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDifference</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">nums</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div> <h4 id="more-straigt-forward">More straigt forward</h4> <p>The removed 3 numbers could be the combination of follows:</p> <ul> <li>The 3 largest</li> <li>The 2 largest + the 1 smallest</li> <li>The 1 largest + the 2 smallest</li> <li>The 3 smallest</li> </ul> <p>The solution above can be written as</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Time: O(NlogN)
# Space: O(1)
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDifference</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">nums</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="mi">4</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div> <h4 id="optimized">Optimized</h4> <p>Furthermore, we can find that what really matters is the 4 largest numbers and the 4 smallest numbers. Suppose we have sorted arrays <code class="language-plaintext highlighter-rouge">max_4</code> and <code class="language-plaintext highlighter-rouge">min_4</code>, which store these numbers separately. The four situations described above are equivalent to:</p> <ul> <li>dis = <code class="language-plaintext highlighter-rouge">max_4[0]</code> - <code class="language-plaintext highlighter-rouge">min_4[0]</code></li> <li>dis = <code class="language-plaintext highlighter-rouge">max_4[1]</code> - <code class="language-plaintext highlighter-rouge">min_4[1]</code></li> <li>dis = <code class="language-plaintext highlighter-rouge">max_4[2]</code> - <code class="language-plaintext highlighter-rouge">min_4[2]</code></li> <li>dis = <code class="language-plaintext highlighter-rouge">max_4[3]</code> - <code class="language-plaintext highlighter-rouge">min_4[3]</code></li> </ul> <p>In other words, we don’t have to sort the entire array; we only need to maintain the top 4 largest numbers and the top 4 smallest numbers.</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Time: O(N)
# Space: O(1)
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDifference</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">min_4</span> <span class="o">=</span> <span class="nf">nsmallest</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">nums</span><span class="p">)</span>
        <span class="n">max_4</span> <span class="o">=</span> <span class="nf">nlargest</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">nums</span><span class="p">)</span>
        <span class="k">return</span> <span class="nf">min</span><span class="p">([</span><span class="n">max_4</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_4</span><span class="p">[</span><span class="mi">3</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><summary type="html"><![CDATA[1509. Minimum Difference Between Largest and Smallest Value in Three Moves (Medium)]]></summary></entry><entry><title type="html">LeetCode 350. Intersection of Two Arrays II</title><link href="https://nasang.github.io/blog/2024/leetcode-350/" rel="alternate" type="text/html" title="LeetCode 350. Intersection of Two Arrays II"/><published>2024-07-02T09:00:00+00:00</published><updated>2024-07-02T09:00:00+00:00</updated><id>https://nasang.github.io/blog/2024/leetcode-350</id><content type="html" xml:base="https://nasang.github.io/blog/2024/leetcode-350/"><![CDATA[<h3 id="350-intersection-of-two-arrays-ii-easy">350. Intersection of Two Arrays II <font color="green">(Easy)</font></h3> <h4 id="initial-solution">Initial Solution</h4> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Time: O(M + 2N) / O(2M + N)
# Space: O(M + N)
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">c_nums1</span> <span class="o">=</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
        <span class="n">c_nums2</span> <span class="o">=</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">c_nums1</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">c_nums2</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">extend</span><span class="p">([</span><span class="n">x1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cnt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div> <h4 id="optimized">Optimized</h4> <p>We only need to count the smaller array to save time and space.</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Time: O(M + N)
# Space: O(min(M, N))
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">intersect</span><span class="p">(</span><span class="n">nums2</span><span class="p">,</span> <span class="n">nums1</span><span class="p">)</span>
        <span class="n">c_nums1</span> <span class="o">=</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c_nums1</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">c_nums1</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div> <h4 id="follow-up">Follow up</h4> <ol> <li>What if the given array is already sorted? How would you optimize your algorithm?</li> </ol> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Time: O(NlogN + MlogM) for sorting; O(min(M, N)) for sorted
# Space: O(1)
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># -- Follow up 1 --
</span>        <span class="n">nums1</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
        <span class="n">nums2</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
        <span class="c1"># -----------------
</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div> <ol> <li>What if <code class="language-plaintext highlighter-rouge">nums1</code>’s size is small compared to <code class="language-plaintext highlighter-rouge">nums2</code>’s size? Which algorithm is better?</li> </ol> <ul> <li>The Optimized solution above.</li> </ul> <ol> <li>What if elements of <code class="language-plaintext highlighter-rouge">nums2</code> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li> </ol> <ul> <li>TBD</li> </ul>]]></content><author><name></name></author><category term="LeetCode"/><summary type="html"><![CDATA[350. Intersection of Two Arrays II (Easy)]]></summary></entry><entry><title type="html">LeetCode 1550. Three Consecutive Odds</title><link href="https://nasang.github.io/blog/2024/leetcode-1550/" rel="alternate" type="text/html" title="LeetCode 1550. Three Consecutive Odds"/><published>2024-07-01T09:00:00+00:00</published><updated>2024-07-01T09:00:00+00:00</updated><id>https://nasang.github.io/blog/2024/leetcode-1550</id><content type="html" xml:base="https://nasang.github.io/blog/2024/leetcode-1550/"><![CDATA[<h3 id="1550-three-consecutive-odds-easy">1550. Three Consecutive Odds <font color="green">(Easy)</font></h3> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Time: O(N)
# Space: O(1)
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">threeConsecutiveOdds</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">n_cons</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">n_cons</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">n_cons</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_cons</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><summary type="html"><![CDATA[1550. Three Consecutive Odds (Easy)]]></summary></entry><entry><title type="html">Designing Data-Intensive Applications (DDIA) Notes</title><link href="https://nasang.github.io/blog/2024/DDIA-notes/" rel="alternate" type="text/html" title="Designing Data-Intensive Applications (DDIA) Notes"/><published>2024-05-16T21:00:00+00:00</published><updated>2024-05-16T21:00:00+00:00</updated><id>https://nasang.github.io/blog/2024/DDIA-notes</id><content type="html" xml:base="https://nasang.github.io/blog/2024/DDIA-notes/"><![CDATA[<h2 id="1-reliable-scalable-and-maintainable-applications">1. Reliable, Scalable, and Maintainable Applications</h2> <p><strong>Reliability</strong> The system should continue to work correctly (performing the correct function at the desired level of performance) even in the face of adversity (hardware or software faults, and even human error).</p> <p><strong>Scalability</strong> As the system grows (in data volume, traffic volume, or complexity), there should be reasonable ways of dealing with that growth.</p> <p><strong>Maintainability</strong> Over time, many different people will work on the system (engineering and operations, both maintaining current behavior and adapting the system to new use cases), and they should all be able to work on it productively.</p>]]></content><author><name></name></author><category term="systems"/><summary type="html"><![CDATA[DDIA reading notes]]></summary></entry></feed>